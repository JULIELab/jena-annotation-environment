/** 
 * ALWorker.java
 * 
 * Copyright (c) 2007, JULIE Lab. 
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0 
 *
 * Author: Klaue
 * 
 * Current version: 2.0
 * Since version:   0.9
 *
 * Creation date: June, 2007 
 * 

 **/

//TODO check exception handling, especially with publish method and in context of SwingWorker scenario
package de.julielab.annoenv.ui.annoclient;

import java.lang.reflect.InvocationTargetException;

import java.sql.Timestamp;

import java.util.List;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.SwingUtilities;

import org.jdesktop.swingworker.SwingWorker;

import de.julielab.annoenv.al.ALClient;
import de.julielab.annoenv.db.annodata.AnnoCore;
import de.julielab.annoenv.db.sql.SQLDatabaseManager;
import de.julielab.annoenv.db.sql.SQLFunctions;
import de.julielab.annoenv.ui.GUIMessages;
import de.julielab.annoenv.utils.AnnoEnvLogger;
import de.julielab.annoenv.utils.Constants;
import de.julielab.annoenv.utils.settings.AnnoClientSettings;

/**
 * ALWorker is a SwingWorker running a background process supervising the Active
 * Learning process. One of its jobs is to regularly check the database for log
 * messages which contain communication information from the AL process to the
 * user (e.g., error messages)
 */
public class ALWorker extends SwingWorker<Long, String> {

	private static Logger logger = AnnoEnvLogger
			.getLogger("de.julielab.annoenv.ui.annoclient.ALWorker");

	final private AnnoClientLogFrame outputFrame;

	private AnnoCore annoProject;

	private boolean isRunning;

	private SQLDatabaseManager sdm;

	private Timestamp ALStartTime;

	private AnnoClientSettings acSettings;

	private SQLFunctions sdf;

	final private Vector<Runnable> miniThreads;

	public ALWorker(AnnoClientLogFrame outputFrame) {
		this.outputFrame = outputFrame;
		acSettings = new AnnoClientSettings();
		this.miniThreads = new Vector<Runnable>();
	}

	/**
	 * runs small tasks on the Event Dispatch Thread before launching the
	 * background task Example: -setting the estimated AL time on ALButton up
	 * for display
	 */
	private void shortTasks() {
		for (Runnable run : miniThreads) {
			try {
				SwingUtilities.invokeAndWait(run);
			} catch (InterruptedException e) {
				throw new RuntimeException("ALWorker crashed.", e);
			} catch (InvocationTargetException e) {
				throw new RuntimeException("ALWorker crashed.", e);
			}
		}
	}

	/**
	 * @return {@code outputFrame} property
	 */
	public AnnoClientLogFrame getOutputFrame() {
		return this.outputFrame;
	}

	/**
	 * @param sdm
	 *            the SQLDatabasemanager
	 */
	public void setSQLDBaseManager(final SQLDatabaseManager sdm) {
		this.sdm = sdm;
		this.sdf = new SQLFunctions(sdm);
	}

	public AnnoCore getProject() {
		return this.annoProject;
	}

	public void setProject(AnnoCore p) {
		this.annoProject = p;
	}

	public void setIsRunning(final boolean b) {
		this.isRunning = b;
	}

	public int getID() {
		return annoProject.getProjectID();
	}

	/**
	 * @param r
	 *            Runnable added to list of short tasks
	 *            {@code ALWorker.shortTasks}
	 */
	public void addRunnable(final Runnable r) {
		miniThreads.add(r);
	}

	/**
	 * Starts AL monitoring thread. If AL is not already running,
	 * {@code doInBackground} requests starting AL via {ALClient.sendALRequest}.
	 * A thread that logs the Active Learning process is started. Output is
	 * generated by {@link SwingWorker.publish} on the{@code outputFrame}.
	 */
	public Long doInBackground() {
		try {
			if (!isRunning) {
				ALStartTime = sdf.getDBSystemTime();
				if (ALClient.sendALRequest(annoProject.getProjectID())) {// AL
					// started
					// =
					// true
					publish("AL started! at ALStartTime: "
							+ ALStartTime.toString());
					// TODO catch errors
				}
			}
			final Thread t = new Thread() {
				int interval = acSettings.AL_REFRESH_INTERVAL;

				public void run() {
					try {
						shortTasks();
						publish((sdf.getALLog(annoProject.getProjectID(),
								ALStartTime).toString()));
						//logger.info("anno client waiting for AL run...");
						while (sdf.getProjectALStatus(
								annoProject.getProjectID()).equals(
								Constants.AL_PROJECT_STATUS_RUNNING)) {
							String publishText = (sdf.getALLog(annoProject
									.getProjectID(), ALStartTime).toString());
							publish(publishText);
							Thread.sleep(interval * 1000);
							//logger.info("wait again");
						}
						// at the end checkif we end up with an error, show the
						// complete log again!
						Thread.sleep(interval * 1000);
						//logger.info("running over");
						String publishText = (sdf.getALLog(annoProject
								.getProjectID(), ALStartTime).toString());
						publish(publishText);

					} catch (Exception e) {
						publish(e.toString());
						GUIMessages.exceptionMessage("AL selection error", e);
						logger.log(Level.SEVERE, "AL selection error", e);
					}
				}
			};

			t.start();
			t.join();
		} catch (Exception e) {
			publish(e.toString());
			String s = null;
			GUIMessages.exceptionMessage("AL selection error", e);
			logger.log(Level.SEVERE, "AL selection error", e);
			s = (new SQLFunctions(sdm)).getALLog(annoProject.getProjectID(),
					ALStartTime);
			publish(s);
		}
		return null;
	}

	public void done() {
		// publish("AL thread finished!");
	}

	protected void process(final List<String> chunks) {
		for (String s : chunks) {
			outputFrame.setText(s + "\n");
		}
	}
}
